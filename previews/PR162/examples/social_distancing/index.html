<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous space social distancing for COVID-19 · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../game_of_life_2D_CA/">Game of life</a></li><li><a class="tocitem" href="../rule22_1D_CA/">Rule 22</a></li><li><a class="tocitem" href="../wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../HK/">Hegselmann-Krause opinion dynamics</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Continuous space social distancing for COVID-19</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous space social distancing for COVID-19</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/social_distancing.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Continuous-space-social-distancing-for-COVID-19-1"><a class="docs-heading-anchor" href="#Continuous-space-social-distancing-for-COVID-19-1">Continuous space social distancing for COVID-19</a><a class="docs-heading-anchor-permalink" href="#Continuous-space-social-distancing-for-COVID-19-1" title="Permalink"></a></h1><p>This is a model similar to our <a href="../sir/#SIR-model-for-the-spread-of-COVID-19-1">SIR model for the spread of COVID-19</a>. But instead of having different cities, we let agents move in one continuous space and transfer the disease if they come into contact with one another. This model is partly inspired by <a href="https://www.washingtonpost.com/graphics/2020/world/corona-simulator/">this article</a>, and can complement the SIR graph model. The graph model can model virus transfer between cities, while the current model can be used to study what happens within a city.</p><p>This example serves also as an introduction to using continuous space, modelling billiard-like collisions in that space, and animating the agent motion in the space. Notice that a detailed description of the basics of the model regarding disease spreading exists in the SIR example, and is not repeated here.</p><h2 id="Moving-agents-in-continuous-space-1"><a class="docs-heading-anchor" href="#Moving-agents-in-continuous-space-1">Moving agents in continuous space</a><a class="docs-heading-anchor-permalink" href="#Moving-agents-in-continuous-space-1" title="Permalink"></a></h2><p>Let us first create a simple model were balls move around in a continuous space. We need to create agents that comply with <a href="../../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, i.e. they have a <code>pos</code> and <code>vel</code> fields, both of which are tuples of float numbers.</p><pre><code class="language-julia">using Agents, Random, AgentsPlots, Plots

mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Float64}
    vel::NTuple{2, Float64}
    mass::Float64
end</code></pre><p>The <code>mass</code> field will come in handy later on, when we implement social isolation (i.e. that some agents don&#39;t move and can&#39;t be moved).</p><p>Let&#39;s also initialize a trivial model with continuous space</p><pre><code class="language-">function ball_model(; speed = 0.002)
    space2d = ContinuousSpace(2; periodic = true, extend = (1, 1))
    model = ABM(Agent, space2d, properties = Dict(:dt =&gt; 1.0));
nothing #hide</code></pre><p>And add some agents to the model</p><pre><code class="language-">    Random.seed!(42)
    for ind in 1:500
        pos = Tuple(rand(2))
        vel = sincos(2π*rand()) .* speed
        add_agent!(pos, model, vel, 1.0)
    end
    index!(model)
    return model
end

model = ball_model()</code></pre><p>We took advantage of the functionality of <a href="../../api/#Agents.add_agent!"><code>add_agent!</code></a> that creates the agents automatically. For now all agents have the same absolute <code>speed</code>, and <code>mass</code>. We <code>index!</code> the model, to make finding space neighbors faster.</p><p>The agent step function for now is trivial. It is just <a href="../../api/#Agents.move_agent!"><code>move_agent!</code></a> in continuous space</p><pre><code class="language-julia">agent_step!(agent, model) =  move_agent!(agent, model, model.properties[:dt])</code></pre><pre><code class="language-none">agent_step! (generic function with 1 method)</code></pre><p><code>dt</code> is our time resolution, but we will talk about this more later! Cool, let&#39;s see now how this model evolves.</p><pre><code class="language-">anim = @animate for i ∈ 1:1000
    p1 = plotabm(model)
    title!(p1, &quot;step $(i)&quot;)
    step!(model, agent_step!, 1)
end
gif(anim, &quot;socialdist1.gif&quot;, fps = 45);
nothing #hide</code></pre><p><img src="socialdist1.gif" alt/></p><p>As you can see the agents move in a straight line in periodic space. There is no interaction yet. Let&#39;s change that.</p><h2 id="Billiard-like-interaction-1"><a class="docs-heading-anchor" href="#Billiard-like-interaction-1">Billiard-like interaction</a><a class="docs-heading-anchor-permalink" href="#Billiard-like-interaction-1" title="Permalink"></a></h2><p>We will model the agents as balls that collide with each other. To this end, we will use two functions from the continuous space API:</p><ol><li><a href="../../api/#Agents.interacting_pairs"><code>interacting_pairs</code></a></li><li><a href="examples/@ref"><code>elastic_collision</code></a></li></ol><p>We want all agents to interact in one go, and we want to avoid double interactions (as instructed by <a href="../../api/#Agents.interacting_pairs"><code>interacting_pairs</code></a>), so we define a model step</p><pre><code class="language-">function model_step!(model)
    for (a1, a2) in interacting_pairs(model, 0.012)
    elastic_collision!(a1, a2, :mass)
    end
end

model2 = ball_model()

anim = @animate for i ∈ 1:100
    p1 = plotabm(model2, as = 4)
    title!(p1, &quot;step $(i)&quot;)
    step!(model2, agent_step!, model_step!, 1)
end
gif(anim, &quot;socialdist2.gif&quot;, fps = 45);
nothing #hide</code></pre><p><img src="socialdist2.gif" alt/></p><p>Alright, this works great so far!</p><div class="admonition"><header class="admonition-header">Agents.jl is not a billiards simulator!</header><div class="admonition-body"><p>Please understand that Agents.jl does not accurately simulate billiard systems. This is the job of Julia packages <a href="https://github.com/JuliaDynamics/HardSphereDynamics.jl">HardSphereDynamics.jl</a> or <a href="https://juliadynamics.github.io/DynamicalBilliards.jl/dev/">DynamicalBilliards.jl</a>. In Agents.jl we only provide an approximating function <code>elastic_collision!</code>. The accuracy of this simulation increases as the time resolution <code>dt</code> decreases, and <strong>only</strong> in the limit <code>dt → 0</code> we reach the accuracy of proper billiard packages.</p><p>Also notice that the plotted size of the circles representing agents is not deduced from the <code>interaction_radius</code> (as it should). We only eye-balled it to look similar enough.</p></div></div><h2 id="Immovable-agents-1"><a class="docs-heading-anchor" href="#Immovable-agents-1">Immovable agents</a><a class="docs-heading-anchor-permalink" href="#Immovable-agents-1" title="Permalink"></a></h2><p>For the following social distancing example, it will become crucial that some agents don&#39;t move, and can&#39;t be moved (i.e. they stay &quot;isolated&quot;). This is very easy to do with the [<code>elastic_collision!</code>] function, we only have to make some agents have infinite mass</p><pre><code class="language-">model3 = ball_model()

for id in 1:40
    agent = id2agent(id, model3)
    agent.mass = Inf
    agent.vel = (0.0, 0.0)
end</code></pre><p>let&#39;s animate this again</p><pre><code class="language-">anim = @animate for i ∈ 1:1000
    p1 = plotabm(model3)
    title!(p1, &quot;step $(i)&quot;)
    step!(model3, agent_step!, model_step!, 1)
end
gif(anim, &quot;socialdist3.gif&quot;, fps = 45);
nothing #hide</code></pre><p><img src="socialdist3.gif" alt/></p><h2 id="Adding-Virus-spread-(SIR)-1"><a class="docs-heading-anchor" href="#Adding-Virus-spread-(SIR)-1">Adding Virus spread (SIR)</a><a class="docs-heading-anchor-permalink" href="#Adding-Virus-spread-(SIR)-1" title="Permalink"></a></h2><p>We now add more functionality to these agents, according to the SIR model (see previous example). They can be infected with a disease and transfer the disease to other agents around them.</p><pre><code class="language-julia">mutable struct PoorSoul &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Float64}
    vel::NTuple{2, Float64}
    mass::Float64
    days_infected::Int  # number of days since is infected
    status::Symbol  # :S, :I or :R
    β::Float64
end</code></pre><p>Here <code>β</code> is the transmission probability, which we choose to make a agent parameter instead of model parameter. It can reflect the level of hygiene of the individual. In a realistic scenario, the actual virus transimission would depend on the <code>β</code> value of both agents, but we don&#39;t do that here for simplicity.</p><p>And we also significantly modify the model creation, to have SIR-related parameters. Each step in the model corresponds to one hour</p><pre><code class="language-">const steps_per_day = 24

using DrWatson: @dict
function sir_initiation(;
        infection_period = 30*steps_per_day, detection_time = 14*steps_per_day,
        reinfection_probability = 0.05,
        isolated = 0.0, # in percentage
        interaction_radius = 0.012, dt = 1.0, speed = 0.002,
        death_rate = 0.044, # from website of WHO
        N=1000,
        initial_infected=5, seed=42,
        βmin = 0.4, βmax = 0.8
    )

    properties = @dict(
        infection_period, reinfection_probability,
        detection_time, death_rate, interaction_radius, dt,
    )
    space = ContinuousSpace(2; periodic = true)
    model = ABM(PoorSoul, space, properties=properties)

    # Add initial individuals
    Random.seed!(seed)
    for ind in 1:N
        pos = Tuple(rand(2))
        status = ind ≤ N - initial_infected ? :S : :I
        isisolated = ind ≤ isolated*N
        mass = isisolated ? Inf : 1.0
        vel = isisolated ? (0.0, 0.0) : sincos(2π*rand()) .* speed</code></pre><p>very high transmission probability we are modelling close encounters after all</p><pre><code class="language-">        β = (βmax-βmin)*rand() + βmin
        add_agent!(pos, model, vel, mass, 0, status, β)
    end

    Agents.index!(model)
    return model
end</code></pre><p>Notice the constant <code>steps_per_day</code>, which approximates how many model steps correspond to one day (since the parameters we used in the previous graph SIR example were given in days).</p><p>To visualize this model, we will use different colors for the infected, recovered and susceptible, leveraging <a href="../../api/#AgentsPlots.plotabm"><code>plotabm</code></a>.</p><pre><code class="language-">sir_model = sir_initiation()

sir_colors(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;

plotabm(sir_model; ac = sir_colors, as = 4)</code></pre><p>We have increased the size of the model 10-fold (for more realistic further analysis)</p><p>To actually spread the virus, we modify the <code>model_step!</code> function, so that individuals have a probability to transmit the disease as they interact.</p><pre><code class="language-julia">function transmit!(a1, a2, rp)
    # for transmission, only 1 can have the disease (otherwise nothing happens)
    count(a.status == :I for a in (a1, a2)) ≠ 1 &amp;&amp; return
    infected, healthy = a1.status == :I ? (a1, a2) : (a2, a1)

    rand() &gt; infected.β &amp;&amp; return

    if healthy.status == :R
        rand() &gt; rp &amp;&amp; return
    end
    healthy.status = :I
end

function sir_model_step!(model)
    r = model.properties[:interaction_radius]
    for (a1, a2) in interacting_pairs(model, r)
        transmit!(a1, a2, model.properties[:reinfection_probability])
        elastic_collision!(a1, a2, :mass)
    end
end</code></pre><pre><code class="language-none">sir_model_step! (generic function with 1 method)</code></pre><p>Notice that it is not necessary that the transmission interaction radius is the same as the billiard-ball dynamics. We only have them here the same for convenience, but in a real model they will probably differ.</p><p>We also modify the <code>agent_step!</code> function, so that we keep track of how long the agent has been infected, and whether they have to die or not.</p><pre><code class="language-julia">function sir_agent_step!(agent, model)
    move_agent!(agent, model, model.properties[:dt])
    update!(agent)
    recover_or_die!(agent, model)
end

update!(agent) = agent.status == :I &amp;&amp; (agent.days_infected += 1)

function recover_or_die!(agent, model)
    if agent.days_infected ≥ model.properties[:infection_period]
        if rand() ≤ model.properties[:death_rate]
            kill_agent!(agent, model)
        else
            agent.status = :R
            agent.days_infected = 0
        end
    end
end</code></pre><pre><code class="language-none">recover_or_die! (generic function with 1 method)</code></pre><p>Alright, now we can animate this process for default parameters</p><pre><code class="language-">sir_model = sir_initiation()

anim = @animate for i ∈ 1:1000
    p1 = plotabm(sir_model; ac = sir_colors, as = 4)
    title!(p1, &quot;step $(i)&quot;)
    step!(sir_model, sir_agent_step!, sir_model_step!, 1)
end
gif(anim, &quot;socialdist4.gif&quot;, fps = 45);
nothing #hide</code></pre><h2 id="Exponential-spread-1"><a class="docs-heading-anchor" href="#Exponential-spread-1">Exponential spread</a><a class="docs-heading-anchor-permalink" href="#Exponential-spread-1" title="Permalink"></a></h2><p>Alright, we can all agree that these animations are cool, but let&#39;s do some actual analysis of this model. The interesting quantity is the number of infected over time, so let&#39;s calculate this, similarly with the graph SIR model.</p><pre><code class="language-julia">infected(x) = count(i == :I for i in x)
recovered(x) = count(i == :R for i in x)
propert = Dict(:status =&gt; [infected, length])</code></pre><pre><code class="language-none">Dict{Symbol,Array{Function,1}} with 1 entry:
  :status =&gt; Function[infected, length]</code></pre><p>Let&#39;s do the following runs, with different parameters probabilities</p><pre><code class="language-">r1, r2 = 0.04, 0.33
β1, β2 = 0.5, 0.1
sir_model1 = sir_initiation(reinfection_probability = r1, βmin = β1)
sir_model2 = sir_initiation(reinfection_probability = r2, βmin = β1)
sir_model3 = sir_initiation(reinfection_probability = r1, βmin = β2)

data1 = step!(sir_model1, sir_agent_step!, sir_model_step!, 2000, propert)
data2 = step!(sir_model2, sir_agent_step!, sir_model_step!, 2000, propert)
data3 = step!(sir_model3, sir_agent_step!, sir_model_step!, 2000, propert)

data1[end-10:end, :]</code></pre><p>Now, we can plot the number of infected versus time</p><pre><code class="language-">p1 = plot(data1[:, Symbol(&quot;infected(status)&quot;)], label = &quot;r=$r1, βmin=$β1&quot;)
plot!(data2[:, Symbol(&quot;infected(status)&quot;)], label = &quot;r=$r2, βmin=$β1&quot;)
plot!(data3[:, Symbol(&quot;infected(status)&quot;)], label = &quot;r=$r1, βmin=$β2&quot;)
yaxis!(p1, &quot;Infected&quot;)
p1</code></pre><p>The exponential growth is quite clear in all cases.</p><h2 id="Social-distancing-1"><a class="docs-heading-anchor" href="#Social-distancing-1">Social distancing</a><a class="docs-heading-anchor-permalink" href="#Social-distancing-1" title="Permalink"></a></h2><p>Of course in reality a dampening mechanism will (hopefully) happen before all population is infected: a vaccine. This effectively introduces a 4th type of status, <code>:V</code> for vaccinated. This type can&#39;t get infected, and thus all remaining individuals that are already infected will (hopefully) survive or die out.</p><p>Until that point, social distancing is practiced. The best way to model social distancing is to make some agents simply not move (which feels like it approximates reality better).</p><pre><code class="language-">sir_model = sir_initiation(isolated = 0.8)

anim = @animate for i ∈ 1:1000
    p1 = plotabm(sir_model; ac = sir_colors, as = 4)
    title!(p1, &quot;step $(i)&quot;)
    step!(sir_model, sir_agent_step!, sir_model_step!, 1)
end
gif(anim, &quot;socialdist5.gif&quot;, fps = 45);
nothing #hide</code></pre><p>Here we let some 20% of the population <em>not</em> being isolated, probably teenagers still partying, or anti-vaxxers / flat-earthers that don&#39;t believe in science. Still, you can see that the spread of the virus is dramatically contained.</p><p>Let&#39;s look at the actual numbers, because animations are cool, but science is even cooler.</p><pre><code class="language-">r4 = 0.04
sir_model4 = sir_initiation(reinfection_probability = r4, βmin = β1, isolated = 0.8)

data4 = step!(sir_model4, sir_agent_step!, sir_model_step!, 2000, propert)

plot!(data4[:, Symbol(&quot;infected(status)&quot;)], label = &quot;r=$r4, βmin=$β1, isol=0.8%&quot;)
yaxis!(p1, &quot;Infected&quot;)
p1</code></pre><p>Here you can see the characteristic &quot;flatten the curve&quot; phrase you hear all over the news.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 26 March 2020 19:49">Thursday 26 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
