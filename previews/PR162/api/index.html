<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Game of life</a></li><li><a class="tocitem" href="../examples/rule22_1D_CA/">Rule 22</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/HK/">Hegselmann-Krause opinion dynamics</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Agent-information-and-retrieval-1"><span>Agent information and retrieval</span></a></li><li><a class="tocitem" href="#Model-Agent-interaction-1"><span>Model-Agent interaction</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives-1"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#Continuous-space-exclusives-1"><span>Continuous space exclusives</span></a></li><li><a class="tocitem" href="#Simulations-1"><span>Simulations</span></a></li><li><a class="tocitem" href="#Schedulers-1"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Parallelization-1"><span>Parallelization</span></a></li><li><a class="tocitem" href="#Plotting-1"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><p>The core API is defined by <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="../tutorial/#Space-1">Space</a>, <a href="../tutorial/#Agents.AbstractAgent"><code>AbstractAgent</code></a> and <a href="../tutorial/#Agents.step!"><code>step!</code></a>, which are described in the <a href="../tutorial/#Tutorial-1">Tutorial</a> page. The functionality described here builds on top of the core API.</p><h2 id="Agent-information-and-retrieval-1"><a class="docs-heading-anchor" href="#Agent-information-and-retrieval-1">Agent information and retrieval</a><a class="docs-heading-anchor-permalink" href="#Agent-information-and-retrieval-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.space_neighbors" href="#Agents.space_neighbors"><code>Agents.space_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">space_neighbors(position, model::ABM [, r]) → ids</code></pre><p>Return the ids of the agents neighboring the given <code>position</code> (which must match type with the spatial structure of the <code>model</code>). If <code>r</code> is given, it is the radius to search for agents.</p><p>For <code>DiscreteSpace</code>s <code>r</code> must be integer and defines higher degree neighbors. For example, for <code>r=2</code> include first and second degree neighbors, that is, neighbors and neighbors of neighbors.</p><p>For <code>ContinuousSpace</code>, <code>r</code> is real number and finds all neighbors within distance <code>r</code> (based on the space&#39;s metric).</p><p>See also <a href="#Agents.node_neighbors"><code>node_neighbors</code></a>.</p><p><code>r</code> defaults to 1 for <code>DiscreteSpace</code> but is mandatory for <code>ContinuousSpace</code>.</p><pre><code class="language-none">space_neighbors(agent::AbstractAgent, model::ABM [, r]) → ids</code></pre><p>Call <code>space_neighbors(agent.pos, model, r)</code> but <em>exclude</em> the given <code>agent</code> from the neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L382-L404">source</a></section><section><div><pre><code class="language-none">space_neighbors(pos::Tuple, model::ABM, r::Real)</code></pre><p>Return IDs of all agents within radius <code>r</code> from a particular position <code>pos</code> for any space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L219-L222">source</a></section><section><div><pre><code class="language-none">space_neighbors(agent::AbstractAgent, model::ABM, r::Real)</code></pre><p>Return neighbours of a particular agent, within radius <code>r</code> for any space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L230-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.id2agent" href="#Agents.id2agent"><code>Agents.id2agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">id2agent(id::Integer, model)</code></pre><p>Return an agent given its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_agent(model)</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L164-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L170-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L176-L179">source</a></section></article><h2 id="Model-Agent-interaction-1"><a class="docs-heading-anchor" href="#Model-Agent-interaction-1">Model-Agent interaction</a><a class="docs-heading-anchor-permalink" href="#Model-Agent-interaction-1" title="Permalink"></a></h2><p>The following API is mostly universal across all types of <a href="../tutorial/#Space-1">Space</a>. Only some specific methods are exclusive to a specific type of space, but we think this is clear from the documentation strings (if not, please open an issue!).</p><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent!(agent::AbstractAgent [, position], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the <code>position</code> in the space and to the list of agents. If <code>position</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_pos!"><code>add_agent_pos!</code></a> to use the <code>agent</code>&#39;s position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L133-L141">source</a></section><section><div><pre><code class="language-none">add_agent!([position, ] model::ABM, properties...)</code></pre><p>Add a new agent at the given <code>position</code>, by constructing the agent type of the <code>model</code> and propagating all <em>extra</em> <code>properties</code> to the agent constructor.</p><p>Notice that this function takes care of setting the agent&#39;s id and position and thus <code>properties...</code> is propagated to other fields the agent has.</p><pre><code class="language-none">add_agent!(model::ABM, properties...)</code></pre><p>Similar with <code>add_agent!(position, model, properties...)</code>, but adds the created agent to a random position. This function also works for models without a spatial structure.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    w::Float64
end
m = ABM(Agent) # model without spatial structure
add_agent!(m, 1, rand()) # incorrect: id is set internally
add_agent!(m, rand()) # correct: weight becomes rand()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L173-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_pos!" href="#Agents.add_agent_pos!"><code>Agents.add_agent_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_single!(agent::A, model::ABM{A, &lt;: DiscreteSpace}, verbose = true) → agent</code></pre><p>Add agent to a random node in the space while respecting a maximum one agent per node. This function throws a warning if no empty nodes remain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L226-L231">source</a></section><section><div><pre><code class="language-none">add_agent_single!(model::ABM, properties...)</code></pre><p>Same as <code>add_agent!(model, properties...)</code> but ensures that it adds an agent into a node with no other agents (does nothing if no such node exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent!(agent::A [, pos], model::ABM{A, &lt;: DiscreteSpace}) → agent</code></pre><p>Add <code>agentID</code> to the new position <code>pos</code> (or a random one if <code>pos</code> is not given) in the model and remove it from the old position (also update the agent to have the new position). <code>pos</code> must be the appropriate position type depending on the space type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L62-L69">source</a></section><section><div><pre><code class="language-none">move_agent!(agent::A, model::ABM{A, ContinuousSpace}, dt = 1.0)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (see <a href="../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>).</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;evolution algorithm&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent_single!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Move agent to a random node while respecting a maximum of one agent per node. If there are no empty nodes, the agent wont move. Only valid for non-continuous spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.kill_agent!" href="#Agents.kill_agent!"><code>Agents.kill_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kill_agent!(agent::AbstractAgent, model::ABM)</code></pre><p>Remove an agent from model, and from the space if the model has a space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.genocide!" href="#Agents.genocide!"><code>Agents.genocide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genocide!(model::ABM)</code></pre><p>Kill all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L33-L36">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, n::Int)</code></pre><p>Kill the agents of the model whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L39-L42">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, f::Function)</code></pre><p>Kill all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/agent_space_interaction.jl#L49-L52">source</a></section></article><h2 id="Discrete-space-exclusives-1"><a class="docs-heading-anchor" href="#Discrete-space-exclusives-1">Discrete space exclusives</a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.node_neighbors" href="#Agents.node_neighbors"><code>Agents.node_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_neighbors(node, model::ABM{A, &lt;:DiscreteSpace} [, r]) → nodes</code></pre><p>Return all nodes that are neighbors to the given <code>node</code>, which can be an <code>Int</code> for <a href="../tutorial/#Agents.GraphSpace"><code>GraphSpace</code></a>, or a <code>NTuple{Int}</code> for <a href="../tutorial/#Agents.GridSpace"><code>GridSpace</code></a>.</p><p>Optional argument <code>r</code> is the radius, similar with <a href="#Agents.space_neighbors"><code>space_neighbors</code></a>.</p><pre><code class="language-none">node_neighbors(agent, model::ABM{A, &lt;:DiscreteSpace} [, r]) → nodes</code></pre><p>Same as above, but uses <code>agent.pos</code> as <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L417-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.nv-Tuple{AgentBasedModel}" href="#LightGraphs.nv-Tuple{AgentBasedModel}"><code>LightGraphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nv(model::ABM)</code></pre><p>Return the number of nodes (vertices) in the <code>model</code> space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.ne-Tuple{AgentBasedModel}" href="#LightGraphs.ne-Tuple{AgentBasedModel}"><code>LightGraphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ne(model::ABM)</code></pre><p>Return the number of edges in the <code>model</code> space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.has_empty_nodes" href="#Agents.has_empty_nodes"><code>Agents.has_empty_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_empty_nodes(model)</code></pre><p>Return true if there are empty nodes in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L331-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.find_empty_nodes" href="#Agents.find_empty_nodes"><code>Agents.find_empty_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_empty_nodes(model::ABM)</code></pre><p>Returns the indices of empty nodes on the model space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.pick_empty" href="#Agents.pick_empty"><code>Agents.pick_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pick_empty(model)</code></pre><p>Return a random empty node or <code>0</code> if there are no empty nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_node_contents" href="#Agents.get_node_contents"><code>Agents.get_node_contents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_node_contents(n::Integer, model)</code></pre><p>Return the ids of agents in the node <code>n</code> of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L343-L347">source</a></section><section><div><pre><code class="language-none">get_node_contents(agent::AbstractAgent, model)</code></pre><p>Return all agents&#39; ids in the same node as the <code>agent</code> (including the agent&#39;s own id).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L350-L354">source</a></section><section><div><pre><code class="language-none">get_node_contents(coords::Tuple, model)</code></pre><p>Return the ids of agents in the node at <code>coords</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L357-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_node_agents" href="#Agents.get_node_agents"><code>Agents.get_node_agents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_node_agents(x, model)</code></pre><p>Same as <code>get_node_contents(x, model)</code> but directly returns the list of agents instead of just the list of IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Integer,AgentBasedModel}" href="#Base.isempty-Tuple{Integer,AgentBasedModel}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(node::Int, model::ABM)</code></pre><p>Return <code>true</code> if there are no agents in <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.NodeIterator" href="#Agents.NodeIterator"><code>Agents.NodeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeIterator(model) → iterator</code></pre><p>Create an iterator that returns node coordinates, if the space is a grid, or otherwise node number, and the agent IDs in each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L469-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nodes" href="#Agents.nodes"><code>Agents.nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodes(model; by = :id) -&gt; ns</code></pre><p>Return a vector of the node ids of the <code>model</code> that you can iterate over. The <code>ns</code> are sorted depending on <code>by</code>:</p><ul><li><code>:id</code> - just sorted by their number</li><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - nodes are sorted depending on how many agents they accommodate. The more populated nodes are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L500-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.coord2vertex" href="#Agents.coord2vertex"><code>Agents.coord2vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coord2vertex(coord::NTuple{Int}, model_or_space) → n
coord2vertex(coord::AbstractAgent, model_or_space) → n</code></pre><p>Return the node number <code>n</code> of the given coordinates or the agent&#39;s position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.vertex2coord" href="#Agents.vertex2coord"><code>Agents.vertex2coord</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertex2coord(vertex::Integer, model_or_space) → coords</code></pre><p>Returns the coordinates of a node given its number on the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/space.jl#L266-L270">source</a></section></article><h2 id="Continuous-space-exclusives-1"><a class="docs-heading-anchor" href="#Continuous-space-exclusives-1">Continuous space exclusives</a><a class="docs-heading-anchor-permalink" href="#Continuous-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interacting_pairs(model, r)</code></pre><p>Return an iterator that yields pairs of agents <code>(a1, a2)</code> that are closest neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of closest agents once (and does not want to trigger the event twice, both with <code>a1</code> and with <code>a2</code>, which is unavoidable when using <code>agent_step!</code>).</p><p>Internally uses <a href="#Agents.nearest_neighbor"><code>nearest_neighbor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L327-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_neighbor(agent, model, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>, according to the space&#39;s metric. Valid only in continuous space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elastic_collision!(a, b, f = nothing)</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L276-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.index!" href="#Agents.index!"><code>Agents.index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index!(model)</code></pre><p>Index the database underlying the <code>ContinuousSpace</code> of the model.</p><p>This can drastically improve performance for retrieving data, but adding new data can become slower because after each addition, index needs to be called again.</p><p>Lack of index won&#39;t be noticed for small databases. Only use it when you have many agents and not many additions of agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/continuous_space.jl#L105-L114">source</a></section></article><h2 id="Simulations-1"><a class="docs-heading-anchor" href="#Simulations-1">Simulations</a><a class="docs-heading-anchor-permalink" href="#Simulations-1" title="Permalink"></a></h2><p>The central simulation function is <a href="../tutorial/#Agents.step!"><code>step!</code></a>, which is mentioned in our <a href="../tutorial/#Tutorial-1">Tutorial</a>. But there are other functions that are related to simulations listed here.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">paramscan(parameters, initialize; kwargs...)</code></pre><p>Run the model with all the parameter value combinations given in <code>parameters</code>, while initializing the model with <code>initialize</code>. This function uses <code>DrWatson</code>&#39;s <a href="https://juliadynamics.github.io/DrWatson.jl/dev/run&amp;list/#DrWatson.dict_list"><code>dict_list</code></a> internally. This means that every entry of <code>parameters</code> that is a <code>Vector</code>, contains many parameters and thus is scanned. All other entries of <code>parameters</code> that are not <code>Vector</code>s are not expanded in the scan.</p><p><code>initialize</code> is a function that creates an ABM. It should accept keyword arguments.</p><p><strong>Keywords</strong></p><p>All the following keywords are propagated into <a href="../tutorial/#Agents.step!"><code>step!</code></a>: <code>agent_step!, properties, n, when = 1:n, model_step! = dummystep</code>, <code>step0::Bool = true</code>, <code>parallel::Bool = false</code>, <code>replicates::Int = 0</code>.</p><p>The following keywords modify the <code>paramscan</code> function:</p><p><code>include_constants::Bool=false</code> determines whether constant parameters should be included in the output <code>DataFrame</code>.</p><p><code>progress::Bool = true</code> whether to show the progress of simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/simulations/data_collector.jl#L177-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, choose an agent property <code>weight</code> (Symbol) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can be chosen more than once.</li><li><code>rng = GLOBAL_RNG</code> : a random number generator to perform the sampling with.</li></ul><p>See the Wright-Fisher example in the documentation for an application of <code>sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/simulations/sample.jl#L4-L20">source</a></section></article><h2 id="Schedulers-1"><a class="docs-heading-anchor" href="#Schedulers-1">Schedulers</a><a class="docs-heading-anchor-permalink" href="#Schedulers-1" title="Permalink"></a></h2><p>The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a &quot;true&quot; iterator or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.fastest" href="#Agents.fastest"><code>Agents.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fastest</code></pre><p>Activate all agents once per step in the order dictated by the agent&#39;s container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.by_id" href="#Agents.by_id"><code>Agents.by_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">by_id</code></pre><p>Activate agents at each step according to their id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L193-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_activation" href="#Agents.random_activation"><code>Agents.random_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_activation</code></pre><p>Activate agents once per step in a random order. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.partial_activation" href="#Agents.partial_activation"><code>Agents.partial_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partial_activation(p)</code></pre><p>At each step, activate only <code>p</code> percentage of randomly chosen agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L213-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.property_activation" href="#Agents.property_activation"><code>Agents.property_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">property_activation(property)</code></pre><p>At each step, activate the agents in an order dictated by their <code>property</code>, with agents with greater <code>property</code> acting first. <code>property</code> is a <code>Symbol</code>, which just dictates which field the agents to compare.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/core/model.jl#L225-L230">source</a></section></article><h2 id="Parallelization-1"><a class="docs-heading-anchor" href="#Parallelization-1">Parallelization</a><a class="docs-heading-anchor-permalink" href="#Parallelization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.parallel_replicates" href="#Agents.parallel_replicates"><code>Agents.parallel_replicates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parallel_replicates(agent_step!, model::ABM, n::Integer, agent_properties::Array{Symbol}, when::AbstractArray{Integer}, replicates::Integer)</code></pre><p>Runs <code>replicates</code> number of simulations in parallel and returns a <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/4ddbe9f4cfcc55e80d91506dcfcc6acf936fc3e8/src/simulations/parallel.jl#L11-L15">source</a></section></article><h2 id="Plotting-1"><a class="docs-heading-anchor" href="#Plotting-1">Plotting</a><a class="docs-heading-anchor-permalink" href="#Plotting-1" title="Permalink"></a></h2><p>Plotting functionality comes from <code>AgentsPlots</code>, which uses Plots.jl. You need to install both <code>AgentsPlots</code>, as well as a plotting backend (we use GR) to use the following functions.</p><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plotabm" href="#AgentsPlots.plotabm"><code>AgentsPlots.plotabm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plotabm(model::ABM [, c , s]; kwargs...)</code></pre><p>Plot the <code>model</code> as a graph by providing two optional <strong>functions</strong> <code>c, s</code>. Both of these functions gain as an input the list of agents <code>a</code> at a node of the model&#39;s graph and output a number. <code>c</code> returns a <em>color</em> (anything acceptable by Plots.jl) of the node while <code>s</code> returhs the (relative) size of the node.</p><p><code>c</code> defaults to a purple color for all nodes, while <code>s</code> defaults to <code>length</code>. Internally the <code>graphplot</code> recipe is used, and thus all keyword arguments are propagated into this recipe.</p><p>If you use <code>plotabm</code> in an animation loop, notice that not all <code>method</code> types of <code>graphplot</code> are deterministic and thus you should probably set <code>Random.seed!</code> before each call to <code>plotabm</code> (and call <code>Random.seed!(rand(1:10000))</code> afterwards to ensure random behavior for your abm).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plot2D" href="#AgentsPlots.plot2D"><code>AgentsPlots.plot2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot2D(node_coords::AbstractArray, colors::AbstractArray; kwargs...)</code></pre><p>Creates a scatter plot for nodes and their colors</p><ul><li>node_coords: node positions as coordinates</li><li>colors: color of each node</li></ul><p><strong>Keywords</strong></p><ul><li>nodesize=1.0</li><li>markeralpha = nothing</li></ul></div></section><section><div><pre><code class="language-none">plot2D(data::AbstractDataFrame, status_column::Symbol; kwargs)</code></pre><p>Plots the distribution of agents on a 2D grid. Agent positions should be saved as tuples.</p><ul><li>data: A dataframe output of your simulation.</li><li>status_column: the name of a column that determines category of each agent,  so that it is colored differently.</li></ul><p><strong>Keywords</strong></p><ul><li>cc::Dict=Dict() Optionally provide a color name for each unique value in the <code>status_column</code></li><li>nodesize=1.0 size of each node</li><li>t=0 the time step of the simulation to plot.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plot_CA1D" href="#AgentsPlots.plot_CA1D"><code>AgentsPlots.plot_CA1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot_CA1D(data; Keywords)</code></pre><p>Visualizes data of a 1D cellular automaton.</p><ul><li><code>data</code>: output of <code>CA1D.ca_run</code>.</li></ul><p><strong>Keywords</strong></p><ul><li>nodesize=2.0: Size of each cell.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plot_CA2D" href="#AgentsPlots.plot_CA2D"><code>AgentsPlots.plot_CA2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot_CA2D(data; kwargs...)</code></pre><p>Visualizes data of a 2D cellular automaton.</p><ul><li><code>data</code>: output of <code>CA2D.ca_run</code>.</li></ul><p><strong>Keywords</strong></p><ul><li>t=nothing : The time step to be plotted. If nothing, all the rows in <code>data</code> are used.</li><li>nodesize=2.0</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plot_CA2Dgif" href="#AgentsPlots.plot_CA2Dgif"><code>AgentsPlots.plot_CA2Dgif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot_CA2Dgif(data; kwargs...)</code></pre><p>Create a 2D scatter plot from all <code>data</code> and adds a frame to the <code>anim</code> animation object. If <code>anim</code> is not provided, it creates a new one. Returns an animation object. It can be saved as an animated gif using <code>AgentsPlots.gif(anim, &quot;filename.gif&quot;)</code>.</p><ul><li><code>data</code>: output of of time-step of <code>CA2D.ca_run</code>.</li></ul><p><strong>Keywords</strong></p><ul><li>anim::Animation=Animation() : animation object. If provided, a new frame is added to it.</li><li>nodesize=2.0</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/HK/">« Hegselmann-Krause opinion dynamics</a><a class="docs-footer-nextpage" href="../mesa/">Comparison against Mesa (Python) »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 26 March 2020 22:46">Thursday 26 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
